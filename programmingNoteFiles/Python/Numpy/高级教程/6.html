<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link type="text/css" rel="stylesheet" href="styles.css">
  <script type="text/javascript" src="config.js"></script>
</head>

<body>
  <h1 class="h">6. 性能优化技巧</h1>
  <dl>
    <dt>1. 向量化（Vectorization）</dt>
    <dd>
      永远避免使用 Python 循环遍历数组元素，使用 NumPy 的内置函数和向量化操作。
      <dl>
        <dt>慢（不要这样做）：</dt>
        <dd>
          <pre><code>a = np.random.rand(1000000)
b = np.random.rand(1000000)
c = np.zeros_like(a)
for i in range(len(a)):
    c[i] = a[i] + b[i]</code></pre>
        </dd>
        <dt>快（应该这样做）：</dt>
        <dd>
          <pre><code>c = a + b # 速度快几个数量级</code></pre>
        </dd>
      </dl>
    </dd>
    <dt>2. 使用 NumPy 自带的函数</dt>
    <dd>NumPy 的函数（如 np.sqrt, np.exp） 是优化过的 C 代码，比自己用循环实现快得多。</dd>
    <dt>3. 预分配内存</dt>
    <dd>
      在需要不断拼接结果时，预先分配一个足够大的数组，然后填充数据，比不断使用 np.concatenate 要高效。
      <dl>
        <dt>次优：</dt>
        <dd>
          <pre><code>result = np.array([])
for i in range(100):
    new_data = ... # 生成一些数据
    result = np.concatenate((result, new_data)) # 每次拼接都复制整个数组，非常慢</code></pre>
        </dd>
        <dt>优化：</dt>
        <dd>
          <pre><code>result = np.empty(10000) # 预先分配足够大的空间
start = 0
for i in range(100):
    new_data = ... # 生成一些数据，假设长度是100
    result[start:start+100] = new_data
    start += 100
result = result[:start] # 最后裁剪到实际大小</code></pre>
        </dd>
      </dl>
    </dd>
  </dl>
</body>

</html>